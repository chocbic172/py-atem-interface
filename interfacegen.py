import yaml
import glob
import os
import shutil
from contextlib import ContextDecorator

PYTHON_HEADER = ("# This file was generated by interfacegen.py\n"
                "# DO NOT EDIT OR ADJUST THIS FILE\n")

class PythonFileWriter(ContextDecorator):
    def __init__(self, output_file_path):
        self.output_file_path = output_file_path
        self.imports = [
            "from enum import Enum",
            "from typing import NamedTuple"
        ]
        self.write_buffer = ""
        self.file_handle = None

    def add_import(self, import_str:str):
        """Add a python import to the top of the file"""
        self.imports.append(import_str)

    def write_ln(self, str_to_write:str):
        """Writes the passed string and a newline to the file"""
        self.write_buffer += f"{str_to_write}\n"

    def write(self, str_to_write:str):
        """Writes the passed string to the file"""
        self.write_buffer += str_to_write

    def __enter__(self):
        """Opens a python file with necessary imports and header

        Creates folders and __init__.py if nessecary. Populates
        __init__ with module imports as new modules are created.
        """
        return self

    def __exit__(self, *exc):
        """We write the entire contents of the file when we've finished
        adding things to the buffer. This means we know all the imports
        before starting to actually write to the file.
        """
        # Create folders if needed
        file_dir = os.path.dirname(self.output_file_path)
        os.makedirs(file_dir, exist_ok=True)

        self.file_handle = open(self.output_file_path, 'w')

        self.file_handle.write(PYTHON_HEADER)
        self.file_handle.write('\n'.join(self.imports) + '\n\n')
        self.file_handle.write(self.write_buffer)

        self.file_handle.close()

        # Once the file has been written, import it in it's modules __init__
        module_init = os.path.join(file_dir, '__init__.py')
        with open(module_init, 'a+') as init_handle:
            init_handle.write(f"from {os.path.basename(self.output_file_path).split('.')[0]} import *\n")
        
        return False

class InterfaceGenerator:
    def __init__(self, interface_file_path) -> None:
        """Load and parse the interface definition, ready for generation"""
        self.parsed_interface_files = self.load_interface_yaml(interface_file_path)

        self.parser_lut = {
            'enum': self.enum_parser,
            'host2device_command': self.command_parser
        }

        # We ignore numbers in types when converting to
        # python types
        self.interface_type_to_python = {
            'bool': bool,
            'sint': int,
            'sfloat': float,
            'string': str,
            'ufloat': float,
            'uint': int,
        }

    @staticmethod
    def load_interface_yaml(interface_file_path: str) -> dict:
        """Load and parse the interface definitions"""

        interface_files = glob.glob('*/*.yaml', root_dir=interface_file_path)
        parsed_files = []

        for module in interface_files:
            module_path = os.path.join(interface_file_path, module)

            with open(module_path, 'r') as handle:
                parsed_data = yaml.safe_load(handle)
                parsed_files.append((module, parsed_data))

        return parsed_files

    def generate_interface(self, root_dir: str):
        """Generates a python interface for each scanned file

        Args:
            root_dir: location to create python interface files
        """

        # Empty directory if it exists
        if os.path.exists(root_dir):
            shutil.rmtree(root_dir)

        os.mkdir(root_dir)

        for module in self.parsed_interface_files:

            interface_objects = list(module[1].keys())
            output_file_name, _ = os.path.splitext(os.path.join(root_dir, module[0]))
            output_file_path = output_file_name + ".py"

            with PythonFileWriter(output_file_path) as output_handle:

                for obj_key in interface_objects:

                    if obj_key.startswith('_'):
                        continue

                    obj = module[1][obj_key]
                    obj_parser = self.parser_lut[obj['_role']]
                    obj_parser(obj, obj_key, output_handle)


    @staticmethod
    def indent_string(input_string:str, level=1):
        """Indents `input_string` using spaces to the specified
        level `level`. Uses google code style.
        """
        output = ""
        indent = "    " * level

        for line in input_string.splitlines():
            output += f"{indent}{line}\n"

        return output

    @staticmethod
    def create_docstring(input_string:str) -> str:
        """Format a docstring to be saved to a python file"""
        COMMENT_BOOKEND = '"""'
        output = (f"{COMMENT_BOOKEND}{input_string}\n"
                  f"{COMMENT_BOOKEND}")
        return output

    def generate_packet_tuple(self, packet:list, key:str, output_handle: PythonFileWriter):
        """Generates a named tuple representing the data of a command packet"""
        tuple_name = key + 'Packet'
        params = []

        for parameter in packet:
            # There should only every be one k:v pair in each item, but
            # a loop is still the most elegant way to parse that
            for (name, interface_type) in parameter.items():

                if name.startswith('bitfield'):
                    flags = interface_type
                    for _ in flags:
                        params.append(self.indent_string(f"{name}: bool"))
                    continue

                if interface_type.startswith('enum'):
                    # Import enum from module (interface.<enum_name>)
                    enum_name = interface_type.split()[-1]
                    enum_module_path, python_type_str = enum_name.split('.')
                    output_handle.add_import(f"from interface.{enum_module_path} import {python_type_str}")
                else:
                    # Type can be handled normally if it's not an enum or bitfield
                    python_type = self.interface_type_to_python[interface_type]
                    python_type_str = type(python_type).__name__

                formatted_str = f"{name}: {python_type_str}"
                params.append(self.indent_string(formatted_str))

        return (f"class {tuple_name}(NamedTuple):\n"
                f"{''.join(params)}")

    def enum_parser(self, enum_dict: dict, key: str, output_handle: PythonFileWriter):
        """Parses an enum object obtained from the yaml interface"""
        enum_values = ""
        documentation = ""

        if "_doc" in enum_dict:
            unformatted_doc = self.create_docstring(enum_dict['_doc'])
            documentation = self.indent_string(unformatted_doc)

        for member, val in enum_dict.items():
            if (member[0] == '_') and (member != '_bits'):
                continue

            # Don't do this, this is bad
            if member == "_bits":
                member = "__bits"

            enum_values += self.indent_string(f"{member} = {val}\n")

        generated_enum = (
            f"class {key}(Enum):\n"
            f"{documentation}"
            f"{enum_values}\n"
        )
        output_handle.write(generated_enum)

    def command_parser(self, command_dict: dict, key:str, output_handle):
        """Generate a function and namedtuple from the
        interface definition of a command packet
        """
        output_handle.write(self.generate_packet_tuple(command_dict['packet'], key, output_handle))

import yaml
import re
import glob
import os
import shutil
import isort
from contextlib import ContextDecorator

PYTHON_HEADER = ("# This file was generated by interfacegen.py\n"
                "# DO NOT EDIT OR ADJUST THIS FILE\n")

DOCSTRING_PARAM = "_doc"

class InterfaceGeneratorException(Exception):
    """Base class for all interface generation exceptiosn"""

class PythonFileWriter(ContextDecorator):
    def __init__(self, output_file_path):
        self.output_file_path = output_file_path
        self.imports = []
        self.write_buffer = ""
        self.file_handle = None

    def process_enum_import(self, import_str: str):
        """Remove circular enum imports by using relative imports
        when the import is within the same module
        """
        MODULE_INDEX = -2
        OBJ_INDEX = -1
        processed_import = ""

        normalised_path = os.path.normpath(self.output_file_path)
        path_dirs = normalised_path.split(os.sep)
        module_name = path_dirs[MODULE_INDEX]
        obj_name = import_str.split()[OBJ_INDEX]

        if module_name in import_str:
            processed_import = f"from .enums import {obj_name}"
        else:
            processed_import = import_str

        return processed_import

    def add_import(self, import_str:str):
        """Add a python import to the top of the file. Ensures no
        ciruclar imports.
        """
        processed_import = self.process_enum_import(import_str)
        self.imports.append(processed_import)

    def write_ln(self, str_to_write:str):
        """Writes the passed string and a newline to the file"""
        self.write_buffer += f"{str_to_write}\n"

    def write(self, str_to_write:str):
        """Writes the passed string to the file"""
        self.write_buffer += str_to_write

    def __enter__(self):
        """Opens a python file with necessary imports and header

        Creates folders and __init__.py if nessecary. Populates
        __init__ with module imports as new modules are created.
        """
        return self

    def __exit__(self, *exc):
        """We write the entire contents of the file when we've finished
        adding things to the buffer. This means we know all the imports
        before starting to actually write to the file.
        """
        # Create folders if needed
        file_dir = os.path.dirname(self.output_file_path)
        os.makedirs(file_dir, exist_ok=True)

        self.file_handle = open(self.output_file_path, 'w')

        self.file_handle.write(PYTHON_HEADER)
        self.file_handle.write(isort.code('\n'.join(self.imports)) + '\n\n')
        self.file_handle.write(self.write_buffer)

        self.file_handle.close()

        # Once the file has been written, import it in it's modules __init__
        module_init = os.path.join(file_dir, '__init__.py')
        with open(module_init, 'a+') as init_handle:
            init_handle.write(f"from .{os.path.basename(self.output_file_path).split('.')[0]} import *\n")

        return False

class InterfaceGenerator:
    def __init__(self, interface_file_path) -> None:
        """Load and parse the interface definition, ready for generation"""
        self.parsed_interface_files = self.load_interface_yaml(interface_file_path)

        self.parser_lut = {
            'enum': self.enum_parser,
            'host2device_command': self.command_parser
        }

        # We ignore numbers in types when converting to
        # python types
        self.interface_type_to_python = {
            'bool': bool,
            'sint': int,
            'sfloat': float,
            'string': str,
            'ufloat': float,
            'uint': int,
        }

    @staticmethod
    def load_interface_yaml(interface_file_path: str) -> dict:
        """Load and parse the interface definitions"""

        interface_files = glob.glob('*/*.yaml', root_dir=interface_file_path)
        parsed_files = []

        for module in interface_files:
            module_path = os.path.join(interface_file_path, module)

            with open(module_path, 'r') as handle:
                parsed_data = yaml.safe_load(handle)
                parsed_files.append((module, parsed_data))

        return parsed_files

    def generate_interface(self, root_dir: str):
        """Generates a python interface for each scanned file

        Args:
            root_dir: location to create python interface files
        """

        # Empty directory if it exists
        if os.path.exists(root_dir):
            shutil.rmtree(root_dir)

        os.mkdir(root_dir)

        for module in self.parsed_interface_files:
            module_path, module_data = module

            interface_objects = list(module_data.keys())
            output_file_name, _ = os.path.splitext(os.path.join(root_dir, module_path))
            output_file_path = output_file_name + ".py"

            with PythonFileWriter(output_file_path) as output_handle:

                for obj_key in interface_objects:

                    if obj_key.startswith('_'):
                        continue

                    obj = module_data[obj_key]
                    obj_parser = self.parser_lut[obj['_role']]
                    obj_parser(obj, obj_key, output_handle)


    @staticmethod
    def indent_string(input_string:str, level=1):
        """Indents `input_string` using spaces to the specified
        level `level`
        """
        output = ""
        indent = "    " * level

        for line in input_string.splitlines():
            output += f"{indent}{line}\n"

        return output

    @staticmethod
    def create_docstring(input_string:str) -> str:
        """Format a docstring to be saved to a python file"""
        COMMENT_BOOKEND = '"""'
        output = (f"{COMMENT_BOOKEND}{input_string}\n"
                  f"{COMMENT_BOOKEND}")
        return output

    def get_enum_length(self, enum:str) -> int:
        """Scan the parsed interface for `enum`, then return it's
        length in bits
        """
        for module in self.parsed_interface_files:
            _, module_data = module

            for obj_key in list(module_data.keys()):

                if obj_key.startswith('_'):
                    continue

                obj = module_data[obj_key]
                if (obj['_role'] == "enum") and (obj_key == enum):
                    return obj['_bits']

        raise InterfaceGeneratorException(f"Could not find length of enum \"{enum}\" in interface.")
                

    def get_command_parameters(self, packet:list):
        """Returns a tuple containing all command parameters and
        their relevant python types (dict), alongside all enum
        imports required for type hinting (list)
        """
        params = {} # As of python 3.7, python dictionaries remember the order items were added
        imports = []

        for parameter in packet:
            for (parameter_name, parameter_data) in parameter.items():

                if parameter_name.startswith('bitfield'):
                    flags = parameter_data
                    for _ in flags:
                        params[parameter_name] = bool.__name__
                    continue

                if parameter_data.startswith('enum'):
                    # Import enum from module (interface.<enum_name>)
                    enum_name = parameter_data.split()[-1]
                    enum_module_path, python_type_str = enum_name.split('.')
                    imports.append(f"from interface.{enum_module_path} import {python_type_str}")
                else:
                    # Type can be handled normally if it's not an enum or bitfield
                    if ("int" in parameter_data):
                        python_type = int
                    elif ("float" in parameter_data):
                        python_type = float
                    elif ("bool" in parameter_data):
                        python_type = bool
                    else:
                        python_type = self.interface_type_to_python[parameter_data]
                    python_type_str = python_type.__name__

                params[parameter_name] = python_type_str

        return params, imports

    def generate_command_packet_parser(self, packet:list):
        """Generates the python script needed to parse a packet"""
        parser_steps = []
        generator_steps = []

        pos_in_packet = 0

        parser_template = "cls.{parameter_name} = {python_type}(cls.buffer.{packet_parser}({args}))"
        generator_template = "buffer.{packet_writer}({args})"

        type_regex = re.compile(r'[a-z]+(\d+)' # Match 1+ letters, then capture following numbers (type length in bits)
                                r'\_*(\d+)*')  # Optionally match '_X', the scale factor (used in floats)

        for parameter in packet:
            parameter_list = list(parameter.items())
            for packet_item_idx in range(len(parameter_list)):

                parameter_name, parameter_data = parameter_list[packet_item_idx]

                if parameter_name.startswith('bitfield'):
                    bitfield_length = int(parameter_name.removeprefix('bitfield'))
                    flags = parameter_data

                    for flag_index in range(len(flags)):
                        python_type_str = bool.__name__
                        buffer_args = (f"offset_bytes={int(pos_in_packet/8)}, "
                                       f"bitfield_len_bits={bitfield_length}, "
                                       f"bit_position={flag_index}")
                        parser_step = parser_template.format(
                            parameter_name=parameter_name,
                            python_type=python_type_str,
                            packet_parser="read_flag",
                            args=buffer_args
                        )
                        generator_step = generator_template.format(
                            packet_writer = "write_flag",
                            args=f"{buffer_args}, value=self.{parameter_name}"
                        )
                        parser_steps.append(parser_step)
                        generator_steps.append(generator_step)

                    pos_in_packet += bitfield_length

                elif parameter_data.startswith('enum'):
                    enum_name = parameter_data.split()[-1]
                    _, python_type_str = enum_name.split('.')
                    enum_encoded_len = self.get_enum_length(python_type_str)

                    buffer_args = (f"offset_bytes={int(pos_in_packet/8)}, "
                                    f"bits={enum_encoded_len}, "
                                    f"signed={False}")
                    parser_step = parser_template.format(
                        parameter_name=parameter_name,
                        python_type=python_type_str,
                        packet_parser="read_int",
                        args=buffer_args
                    )
                    generator_step = generator_template.format(
                            packet_writer = "write_int",
                            args=f"{buffer_args}, value=self.{parameter_name}.value"
                    )

                    pos_in_packet += enum_encoded_len
                    parser_steps.append(parser_step)
                    generator_steps.append(generator_step)

                elif ('int' in parameter_data):
                    python_type = int
                    python_type_str = python_type.__name__
                    packed_float_len, _ = type_regex.match(parameter_data).groups()
                    signed = (parameter_data[0] == 's')

                    buffer_args = (f"offset_bytes={int(pos_in_packet/8)}, "
                                    f"bits={packed_float_len}, "
                                    f"signed={signed}")
                    parser_step = parser_template.format(
                        parameter_name=parameter_name,
                        python_type=python_type_str,
                        packet_parser="read_int",
                        args=buffer_args
                    )
                    generator_step = generator_template.format(
                            packet_writer = "write_int",
                            args=f"{buffer_args}, value=self.{parameter_name}"
                    )

                    pos_in_packet += int(packed_float_len)
                    parser_steps.append(parser_step)
                    generator_steps.append(generator_step)

                elif ('float' in parameter_data):
                    python_type = float
                    python_type_str = python_type.__name__
                    packed_float_len, scale_factor = type_regex.match(parameter_data).groups()
                    signed = (parameter_data[0] == 's')

                    buffer_args = (f"offset_bytes={int(pos_in_packet/8)}, "
                                   f"bits={packed_float_len}, "
                                   f"factor={scale_factor}, "
                                   f"signed={signed}")
                    parser_step = parser_template.format(
                        parameter_name=parameter_name,
                        python_type=python_type_str,
                        packet_parser="read_float",
                        args=buffer_args
                    )
                    generator_step = generator_template.format(
                            packet_writer = "write_float",
                            args=(f"{buffer_args}, value=self.{parameter_name}")
                    )

                    pos_in_packet += int(packed_float_len)
                    parser_steps.append(parser_step)
                    generator_steps.append(generator_step)

        return parser_steps, generator_steps

    def enum_parser(self, enum_dict: dict, key: str, output_handle: PythonFileWriter):
        """Parses an enum object obtained from the yaml interface"""
        enum_values = ""
        documentation = ""

        if DOCSTRING_PARAM in enum_dict:
            unformatted_doc = self.create_docstring(enum_dict[DOCSTRING_PARAM])
            documentation = self.indent_string(unformatted_doc)

        for member, val in enum_dict.items():
            if (member[0] == '_') and (member != '_bits'):
                continue

            # Don't do this, this is bad
            if member == "_bits":
                member = "__bits"

            enum_values += self.indent_string(f"{member} = {val}\n")

        generated_enum = (
            f"class {key}:\n"
            f"{documentation}"
            f"{enum_values}\n"
        )
        output_handle.write(generated_enum)

    def command_parser(self, command_dict: dict, key:str, output_handle: PythonFileWriter):
        """Generate a function and namedtuple from the
        interface definition of a command packet
        """
        documentation = ""
        command_name = key + 'Packet'
        command_imports = ["from __future__ import annotations"]
        command_params, enum_imports = self.get_command_parameters(command_dict['packet'])

        command_imports.extend(enum_imports)

        # Store all variables for internal use
        internal_variables = ""
        for key, val in command_dict.items():
            if (key.startswith('_')) and (key != DOCSTRING_PARAM):
                python_key = f"_{key}"
                formatted_val = f"\"{val}\"" if type(val) == str else val
                internal_variables += self.indent_string(f"{python_key} = {formatted_val}")

        if DOCSTRING_PARAM in command_dict:
            unformatted_doc = self.create_docstring(command_dict[DOCSTRING_PARAM])
            documentation = self.indent_string(unformatted_doc)

        for enum_import in command_imports:
            output_handle.add_import(enum_import)

        function_params_formatted = ', '.join(f"{param}: {param_type}"
                                               for param, param_type in command_params.items())
        class_variable_setters = ''.join(self.indent_string(f"self.{param}:{param_type} = {param}")
                                           for param, param_type in command_params.items())

        output_handle.add_import("from packet import *")

        init_func = self.indent_string(f"def __init__(self, {function_params_formatted}):\n"
                                       f"{documentation}\n"
                                       f"{self.indent_string("self.buffer = PacketBuffer(self.__bits)")}"
                                       f"{class_variable_setters}")

        from_bytes_steps, to_bytes_steps = self.generate_command_packet_parser(command_dict['packet'])
        from_bytes_func = self.indent_string("@classmethod\n"
                                             f"def from_bytes(cls, packet: bytes) -> {command_name}:\n"
                                             "    cls.buffer = PacketBuffer.from_bytes(packet)\n"
                                             f"{self.indent_string('\n'.join(from_bytes_steps))}")

        to_bytes_func = self.indent_string("def to_bytes(self) -> bytes:\n"
                                           "    buffer = PacketBuffer(int(self.__bits/8))\n"
                                           f"{self.indent_string('\n'.join(to_bytes_steps))}"
                                           "    return buffer.buffer[:]")

        command_class = (f"class {command_name}(PacketABC):\n"
                         f"{internal_variables}\n"
                         f"{init_func}\n"
                         f"{from_bytes_func}\n"
                         f"{to_bytes_func}")

        output_handle.write(command_class)
